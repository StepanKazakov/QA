Начало работы с тестами
Чтобы попробовать написать тестовый сценарий в первый раз, откройте запрос в приложении Postman и откройте вкладку Tests. Введите следующий код JavaScript:

pm.test("Status code is 200", function () {
  pm.response.to.have.status(200);
});
Этот код использует библиотеку pm для запуска testметода. Текстовая строка появится в выводе теста. Функция внутри теста представляет собой утверждение. Тесты почтальона могут использовать синтаксис BDD библиотеки утверждений Chai, который предоставляет возможности для оптимизации того, насколько удобочитаемы ваши тесты для вас и ваших сотрудников. В этом случае код использует цепочки BDD to.haveдля выражения утверждения.

Этот тест проверяет код ответа, возвращаемый API. Если код ответа есть 200, тест пройдет, в противном случае он завершится неудачей. Нажмите Отправить и проверьте вывод результатов теста в области ответов.

Попробуйте изменить код состояния в коде утверждения и запустить его снова, чтобы увидеть, как результаты теста выглядят по-разному, когда они проходят или не проходят.



Вы можете структурировать свои тестовые утверждения различными способами в соответствии с вашей логикой и предпочтениями с точки зрения того, как вы хотите выводить результаты. Следующий код является альтернативным способом выполнения того же теста, что и приведенный выше, с использованием expectсинтаксиса:

pm.test("Status code is 200", () => {
  pm.expect(pm.response.code).to.eql(200);
});
 

Использование нескольких утверждений
Ваши тесты могут включать несколько утверждений как часть одного теста, вы можете использовать это для группировки связанных утверждений.

pm.test("The response has all properties", () => {
    // разобрать json ответ и проверить три свойства
    const responseJson = pm.response.json();
    pm.expect(responseJson.type).to.eql('vip');
    pm.expect(responseJson.name).to.be.a('string');
    pm.expect(responseJson.id).to.have.lengthOf(1);
});
Если какое-либо из содержащихся утверждений завершится неудачно, тест в целом завершится неудачно. Все утверждения должны быть успешными, чтобы тест прошел успешно.

Примечание переводчика: как прервать проверку если условие не выполнено нужно уточнить.

 

Анализ данных тела ответа
Чтобы выполнить утверждения в ваших ответах, вам сначала нужно будет проанализировать данные в объекте JavaScript, который могут использовать ваши утверждения.

Для разбора данных JSON используйте следующий синтаксис:

const responseJson = pm.response.json();
Для разбора XML используйте следующее:

const responseJson = xml2Json(pm.response.text());
Примечание: Если вы имеете дело со сложными XML-ответами, вам может пригодиться запись в журнал консоли.

Для анализа CSV используйте утилиту анализа CSV:

const parse = require('csv-parse/lib/sync');
const responseJson = parse(pm.response.text());
Для анализа HTML вы можете использовать cheerio:

const $ = cheerio.load(pm.response.text());
//вывод html-кода для тестирования
console.log($.html());
 

Обработка ответов, которые не парсятся
Если вы не можете проанализировать тело ответа на JavaScript, потому что оно не отформатировано как JSON, XML, HTML, CSV или любой другой формат данных, поддающийся анализу, вы все равно можете делать утверждения в отношении данных.

Вы можете проверить, содержит ли тело ответа строку:

pm.test("Body contains string",() => {
  pm.expect(pm.response.text()).to.include("customer_id");
});
Это не покажет вам, где была обнаружена строка, потому что она выполняет проверку всего тела ответа. 

Вы также можете проверить, соответствует ли ответ строке (что обычно эффективно только при коротких ответах):

pm.test("Body is string", function () {
  pm.response.to.have.body("whole-body-text");
});
Примечание переводчика: для формата например "x-form-urlencoded" и подобного думаю возможно найти библиотеки и подключить их в тесты.

 

Создание утверждений в HTTP-ответе
Ваши тесты могут проверять различные аспекты ответа на запрос, включая текст, коды состояния, заголовки, файлы cookie, время ответа и многое другое.

 

Тестирование тела ответа
Вы можете проверить наличие определенных значений в теле ответа:

pm.test("Person is Jane", () => {
  const responseJson = pm.response.json();
  pm.expect(responseJson.name).to.eql("Jane");
  pm.expect(responseJson.age).to.eql(23);
});
 

Тестирование кодов состояния
Вы можете проверить код состояния ответа:

pm.test("Status code is 201", () => {
  pm.response.to.have.status(201);
});
Если вы хотите проверить, является ли код состояния одним из набора, вы можете включить их все в массив и использоватьoneOf:

pm.test("Successful POST request", () => {
  pm.expect(pm.response.code).to.be.oneOf([201,202]);
});
 

Тестирование заголовков
Вы можете проверить наличие заголовка ответа:

pm.test("Content-Type header is present", () => {
  pm.response.to.have.header("Content-Type");
});
Вы также можете проверить заголовок ответа, имеющий определенное значение:

pm.test("Content-Type header is application/json", () => {
  pm.expect(pm.response.headers.get('Content-Type')).to.eql('application/json');
});
 

Тестирование файлов cookie
Примечание переводчика: По сути это заголовок с в виде строки c данными разделенными ";".

Вы можете проверить, присутствует ли файл cookie в ответе:

pm.test("Cookie JSESSIONID is present", () => {
  pm.expect(pm.cookies.has('JSESSIONID')).to.be.true;
});
Вы также можете проверить наличие определенного значения файла cookie:

pm.test("Cookie isLoggedIn has value 1", () => {
  pm.expect(pm.cookies.get('isLoggedIn')).to.eql('1');
});
 

Тестирование времени отклика
Вы можете проверить, чтобы время отклика находилось в заданном диапазоне:

pm.test("Response time is less than 200ms", () => {
  pm.expect(pm.response.responseTime).to.be.below(200);
});
 

Общие примеры проверок (assertion)
Читайте дальше, чтобы найти некоторые примеры распространенных проверок, которые могут оказаться полезными в ваших сценариях, как они описаны ниже, или отредактировав детали в соответствии с вашими собственными потребностями.

 
Проверка значения ответа по переменной
Вы можете проверить, имеет ли свойство ответа то же значение, что и переменная (в данном случае переменная среды).

pm.test("Response property matches environment variable", function () {
  pm.expect(pm.response.json().name).to.eql(pm.environment.get("name"));
});
В разделе Использование переменных приведен обзор операций, которые можно использовать для управления переменными в ваших сценариях.

 

Проверка типа значения
Вы можете проверить тип любой части ответа.

/* ответ имеет такую структуру:
{
  "name": "Jane",
  "age": 29,
  "hobbies": [
    "skating",
    "painting"
  ],
  "email": null
}
*/
const jsonData = pm.response.json();
pm.test("Test data type of the response", () => {
  pm.expect(jsonData).to.be.an("object");
  pm.expect(jsonData.name).to.be.a("string");
  pm.expect(jsonData.age).to.be.a("number");
  pm.expect(jsonData.hobbies).to.be.an("array");
  pm.expect(jsonData.website).to.be.undefined;
  pm.expect(jsonData.email).to.be.null;
});
 

Проверка свойств массива
Вы можете проверить, является ли массив пустым или нет, и содержит ли он определенные элементы.

/*
ответ имеет такую структуру:
{
  "errors": [],
  "areas": [ "goods", "services" ],
  "settings": [
    {
      "type": "notification",
      "detail": [ "email", "sms" ]
    },
    {
      "type": "visual",
      "detail": [ "light", "large" ]
    }
  ]
}
*/

const jsonData = pm.response.json();
pm.test("Test array properties", () => {
    //массив ошибок пуст
  pm.expect(jsonData.errors).to.be.empty;
    //массив включает в себя "товары"
  pm.expect(jsonData.areas).to.include("goods");
    
  //получить объект настроек уведомлений
  const notificationSettings = jsonData.settings.find
      (m => m.type === "notification");
  pm.expect(notificationSettings)
    .to.be.an("object", "Could not find the setting");
    //массив "detail" должен включать "sms"
  pm.expect(notificationSettings.detail).to.include("sms");
    //массив "detail" должен включать все перечисленные элементы
  pm.expect(notificationSettings.detail)
    .to.have.members(["email", "sms"]);
});
 

Проверка свойств объекта
Вы можете проверить, что объект содержит ключи или свойства.

pm.expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
pm.expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
pm.expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
pm.expect({a: 1}).to.have.property('a');
pm.expect({a: 1, b: 2}).to.be.an('object')
  .that.has.all.keys('a', 'b');
Целью может быть object, set, arrayили map. Если .keysвыполняется без .allили .any, выражение по умолчанию равно .all. Поскольку .keysповедение зависит от type, рекомендуется проверить typeперед использованием .keysс помощью .a.

 

Проверка, что значение находится в наборе
Вы можете проверить значение ответа по списку допустимых параметров.

pm.test("Value is in valid list", () => {
  pm.expect(pm.response.json().type)
    .to.be.oneOf(["Subscriber", "Customer", "User"]);
});
 

Проверка, что объект содержится в ответе
Вы можете проверить, является ли объект частью родительского объекта.

/*
ответ имеет следующую структуру:
{
  "id": "d8893057-3e91-4cdd-a36f-a0af460b6373",
  "created": true,
  "errors": []
}
*/

pm.test("Object is contained", () => {
  const expectedObject = {
    "created": true,
    "errors": []
  };
  pm.expect(pm.response.json()).to.deep.include(expectedObject);
});
Использование .deepзаставляет все.equal.include,.members,.keys, и .propertyутверждения , которые следуют в цепочке, использовать глубокое равенство (свободное равенство) вместо строгого (===) равенства. В то время .eqlкак также сравнивается слабо, .deep.equalприводит к тому, что сравнения с глубоким равенством также используются для любых других утверждений, которые следуют в цепочке, в то время .eqlкак это не так.

 

Проверка текущего окружения
Вы можете проверить активную (выбранную в данный момент) среду в Postman.

pm.test("Check the active environment", () => {
  pm.expect(pm.environment.name).to.eql("Production");
});
 

Устранение распространенных ошибок тестирования
Когда вы сталкиваетесь с ошибками или неожиданным поведением в своих тестовых сценариях, консоль почтальона может помочь вам определить источник. Комбинируя console.logинструкции отладки с утверждениями теста, вы можете изучить содержимое HTTP-запросов и ответов, а также элементы данных почтальона, такие как переменные.

 

Вы можете записать значение переменной или свойства ответа:

console.log(pm.collectionVariables.get("name"));
console.log(pm.response.json().name);
Вы можете записать тип переменной или свойства ответа:

console.log(typeof pm.response.json().id);
Вы можете использовать журналы консоли для обозначения выполнения кода, иногда известного как "операторы трассировки":

if (pm.response.json().id) {
  console.log("id was found!");
  // do something
} else {
  console.log("no id ...");
  //do something else
}
 

Ошибка проверки равенства
Вы можете столкнуться с AssertionError: expected <value> to deeply equal '<value>'. Например, это может возникнуть при использовании следующего кода:

pm.expect(1).to.eql("1");
Это происходит потому, что тест сравнивает число со строковым значением. Тест вернет значение true только в том случае, если и тип, и значение равны.

 

Ошибка JSON не определен
Вы можете столкнуться с этой ReferenceError: jsonData is not definedпроблемой. Обычно это происходит, когда вы пытаетесь ссылаться на объект JSON, который не был объявлен или находится за пределами области действия вашего тестового кода.

pm.test("Test 1", () => {
  const jsonData = pm.response.json();
  pm.expect(jsonData.name).to.eql("John");
});

pm.test("Test 2", () => {
  pm.expect(jsonData.age).to.eql(29); // jsonData не определен
});
Убедитесь, что любой код, устанавливающий данные вашего ответа в переменную, доступен для всего тестового кода, например, в этом случае вызовconst jsonData = pm.response.json();перед pm.testсделает его доступным для обеих тестовых функций.

 

Неопределенная ошибка проверки
Вы можете столкнуться с этой AssertionError: expected undefined to deeply equal..проблемой. Обычно это происходит, когда вы ссылаетесь на свойство, которое не существует или находится вне области действия.

pm.expect(jsonData.name).to.eql("John");
В приведенном выше примере, если вы видите AssertionError: expected undefined to deeply equal 'John', это указывает на то, что nameсвойство не определено в jsonDataобъекте.

 

Тест не провалился
Могут быть случаи, когда вы ожидаете, что тест провалится, но этого не происходит.

//тестовая функция не определена должным образом - отсутствует второй параметр
pm.test("Not failing", function () {
    pm.expect(true).to.eql(false);
});
Убедитесь, что ваш тестовый код синтаксически корректен, и повторите попытку отправки запроса.

 

Проверка структуры ответа
Вы можете выполнить проверку схемы JSON с помощью tv4

Примечание переводчика: Tiny Validator (for v4 JSON Schema), устарел, выдает общий статус проверки.

const schema = {
 "items": {
 "type": "boolean"
 }
};
const data1 = [true, false];
const data2 = [true, 123];

pm.test('Schema is valid', function() {
  pm.expect(tv4.validate(data1, schema)).to.be.true;
  pm.expect(tv4.validate(data2, schema)).to.be.true;
});
Вы также можете проверить схему JSON с помощью ajv по умолчанию.

Примечание переводчика: Ajv JSON schema validator, выдает развернутую ошибку AssertionError: expected data to satisfy schema but found following errors:...

const schema = {
  "properties": {
    "alpha": {
      "type": "boolean"
    }
  }
};
pm.test('Schema is valid', function() {
  pm.response.to.have.jsonSchema(schema);
});
Примечание переводчика: Использование Ajv для объекта

var Ajv = require('ajv'),
    ajv = new Ajv({logger: console});

pm.test("Response use a valid schema", function() {
    pm.expect(ajv.validate(cam, RECTILINEAR_SCHEMA)).to.be.true;
    });
 

Отправка асинхронного запроса
Вы можете отправить запрос из своего кода тестов и зарегистрировать ответ.

pm.sendRequest("https://postman-echo.com/get", function (err, response) {
    console.log(response.json());
});